from typing import Annotated

from pydantic import Field
from langchain_core.tools import tool
from langgraph.prebuilt import InjectedState
from langgraph.types import Command
from langchain_core.messages import ToolMessage

from ..agent_state import ToolCallResult

# 代码规范:
# 工具函数以 _tool 结尾, 在装饰器的第一个参数中指定实际名称(删去 _tool 后缀)
# 装饰器中需加入 parse_docstring=True 来自动解析文档字符串, 文档字符串中需包含 Args 部分来描述参数
# 需要校验的参数使用 Annotated 和 Field 进行类型和约束定义

@tool("example", parse_docstring=True)
def example_tool(
    example_param1: str,
    example_param2: Annotated[int, Field(gt=0, lt=100)]
):
    """示例工具函数

        函数描述

    Args:
        example_param1: 示例参数1
        example_param2: 示例参数2, 范围在0到100之间
    """
    pass
    return f"Example with param1: {example_param1} and param2: {example_param2}"

# 如果需要使用状态, 则将第一个参数设为 state: Annotated[dict, InjectedState]. 状态参数不需要在文档字符串中描述
# 如果需要更新状态, 则返回 Command 对象, 并在 update 字段中指定要更新的状态内容
# 在更新状态的同时也需要返回消息给 Agent, 需要在返回值的 message 中添加 ToolMessage 对象, 并指定 tool_call_id 字段

@tool("example_with_state", parse_docstring=True)
def example_with_state_tool(
    state: Annotated[dict, InjectedState],
    example_param1: str,
    example_param2: Annotated[int, Field(gt=0, lt=100)]
):
    """示例工具函数

        该示例函数展示了如何使用状态

    Args:
        example_param1: 示例参数1
        example_param2: 示例参数2, 范围在0到100之间
    """
    pass
    
    # 获取 tool_call_id
    # 从消息列表的最后一条中获取 ID
    last_message = state["messages"][-1]
    # 找到当前工具对应的 ID
    current_tool_call = next(
        (tc for tc in last_message.tool_calls if tc["name"] == "generate_image"),
        None
    )
    # 如果无法获取对应的 tool_call_id, 则返回错误信息
    if not current_tool_call:
        return "无法获取 tool_call_id"
    # 成功获取 tool_call_id
    tid = current_tool_call["id"]

    # 构造发送到 QQ 的结构化结果列表 (ToolCallResult)
    structured_results: list[ToolCallResult] = [
        {
            "tool_name": "example_with_state",
            "id": f"{tid}_{index}",
            "type": "file",
            "content": r["url"]
        }
        for index, r in enumerate(final_results) if "url" in r
    ]

    return Command(
        update={
            # 返回给 Agent 的内容
            # 注意: 必须带上 tool_call_id
            "messages": [
                ToolMessage(
                    content="tool executed successfully",
                    tool_call_id=tid
                )
            ],
            # 如果结果需要发送到 QQ, 则添加到 tool_call_results
            "tool_call_results": structured_results
            # 更新其他状态
            "example_state": "updated value"
        }
    )


__all__ = ["example_tool", "example_with_state_tool"]
